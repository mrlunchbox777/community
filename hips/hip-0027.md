---
hip: 0027
title: "Expose Previously Installed Chart Metadata During Template Rendering"
authors: [ "Andrew Shoell <mrlunchbox777@gmail.com>" ]
created: "2025-11-12"
type: "feature"
status: "draft"
---

## Abstract

This HIP proposes exposing metadata from the currently deployed chart version during template rendering for upgrade and rollback operations. Currently, Helm templates have access to `.Chart` which provides metadata about the chart being installed (name, version, appVersion, etc.), but no equivalent access to information about the release currently deployed in the cluster. This limitation prevents, or requires complex workarounds from, chart authors implementing upgrade-aware logic that could facilitate smoother migrations, conditional resource modifications, or version-specific transformations.

The proposal introduces a new `.DeployedChart` object available in the template context during `helm upgrade` and `helm rollback` operations. This object would contain the same metadata structure as `.Chart` but populated with values from the release currently running in the cluster. When no previous release exists (such as during initial installation), `.DeployedChart` would be nil, allowing templates to safely check for its existence.

This enhancement enables chart maintainers to build more intelligent upgrade paths, implement breaking change migrations, conditionally apply resource changes based on version deltas, and provide better user experiences during chart upgrades without requiring external tooling or complex pre-upgrade hooks.

## Motivation

### Current Limitations

Helm's current template rendering model provides comprehensive information about the chart being installed through the `.Chart` object, but offers no native way to access metadata from the previously deployed release during template evaluation. This asymmetry creates significant challenges for chart authors who need to implement version-aware upgrade logic.

Today, chart developers who need to handle version-specific migrations or conditional upgrades must resort to workarounds that are complex, fragile, and outside Helm's intended design:

**1. Post-Renderers:** The most common workaround involves implementing custom post-renderers that modify manifests after template rendering but before application. These external tools must:
- Query the cluster to retrieve the current release
- Parse and understand the rendered manifests
- Make version-aware modifications to YAML
- Handle edge cases like initial installations vs. upgrades

This approach is problematic because it moves upgrade logic outside the chart itself, requires users to install additional tooling, and breaks the self-contained nature of Helm charts.

**2. Pre-Upgrade Hooks with ConfigMaps:** Some charts store version metadata in ConfigMaps via pre-upgrade hooks, then reference these values in templates. This creates ordering dependencies, increases the number of Kubernetes resources, and can fail if hooks don't execute properly.

**3. Values File Conventions:** Requiring users to manually specify the previous version in values files is error-prone and defeats the purpose of Helm tracking release history.

### Real-World Impact

The lack of previous version metadata at template time prevents or significantly complicates several legitimate use cases:

**Breaking Changes:** When a chart introduces breaking changes (e.g., renaming a Secret, changing a ConfigMap structure, or modifying PVC specifications), there's no clean way to handle the migration. Chart authors must either force users through manual steps or abandon backwards compatibility entirely.

**Conditional Resource Creation:** Charts cannot conditionally create migration Jobs or temporary resources based on the version delta. For example, a database chart upgrading from v1.x to v2.x might need to run a one-time data migration Job only when crossing that major version boundary.

**Smart Defaults:** Charts cannot provide intelligent defaults based on what was previously deployed. A chart might want to preserve certain legacy behaviors for existing installations while adopting new defaults for fresh installations, but cannot distinguish between these scenarios at template time.

**Blue-Green Deployments:** Advanced deployment strategies that require knowledge of both the old and new versions cannot be implemented purely within Helm templates, forcing users to orchestrate these scenarios with external tools.

### Why Template-Time Access Matters

Post-rendering solutions fundamentally break Helm's design philosophy. Template rendering should be deterministic and self-containedâ€”the same chart with the same values should produce the same output. Post-renderers violate this principle by introducing external dependencies and cluster state into the rendering process at the wrong layer.

Making previous chart metadata available during template rendering keeps upgrade logic where it belongs: in the chart itself. This maintains the portability, testability, and transparency that make Helm valuable while enabling sophisticated upgrade scenarios that are currently impossible or require significant infrastructure around Helm.

## Rationale

Describe why particular design decisions were made.

## Specification

Describe the syntax and semantics of any new feature.

## Backwards compatibility

Describe potential impact and severity on pre-existing code.

## Security implications

How could a malicious user take advantage of this new feature?

## How to teach this

How to teach users, new and experienced, how to apply the HIP to their work.

## Reference implementation

Link to any existing implementation and details about its state, e.g.
proof-of-concept.

## Rejected ideas

Why certain ideas that were brought while discussing this HIP were not
ultimately pursued.

## Open issues

Any points that are still being decided/discussed.

## References

A collection of URLs or materials used as references through the HIP.
