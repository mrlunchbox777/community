---
hip: 0027
title: "Expose Previously Installed Chart Metadata During Template Rendering"
authors: [ "Andrew Shoell <mrlunchbox777@gmail.com>" ]
created: "2025-11-12"
type: "feature"
status: "draft"
---

## Abstract

This HIP proposes exposing metadata from the currently deployed chart version during template rendering for upgrade and rollback operations. Currently, Helm templates have access to `.Chart` which provides metadata about the chart being installed (name, version, appVersion, etc.), but no equivalent access to information about the release currently deployed in the cluster. This limitation prevents chart authors from implementing upgrade-aware logic, forcing them to rely on complex workarounds such as post-renderers, pre-upgrade hooks, or manual values file conventions.

The proposal introduces a new `.DeployedChart` object available in the template context during `helm upgrade` and `helm rollback` operations. This object contains the same metadata structure as `.Chart` but is populated with values from the chart version currently running in the cluster. When no previous release exists (such as during initial installation), `.DeployedChart` is nil, allowing templates to safely check for its existence with `{{ if .DeployedChart }}`.

This enhancement enables chart maintainers to build intelligent upgrade paths that can detect version transitions, implement breaking change migrations, conditionally apply resources based on version deltas, and provide seamless user experiences during chart lifecycle operations—all within the chart itself without requiring external tooling. An optional `--disable-deployed-chart` flag allows users to opt out of this feature for security or determinism requirements.

## Motivation

### Current Limitations

Helm's current template rendering model provides comprehensive information about the chart being installed through the `.Chart` object, but offers no native way to access metadata from the previously deployed release during template evaluation. This asymmetry creates significant challenges for chart authors who need to implement version-aware upgrade logic.

Today, chart developers who need to handle version-specific migrations or conditional upgrades must resort to workarounds that are complex, fragile, and outside Helm's intended design:

**1. Post-Renderers:** The most common workaround involves implementing custom post-renderers that modify manifests after template rendering but before application. These external tools must:
- Query the cluster to retrieve the current release
- Parse and understand the rendered manifests
- Make version-aware modifications to YAML
- Handle edge cases like initial installations vs. upgrades

This approach is problematic because it moves upgrade logic outside the chart itself, requires users to install additional tooling, and breaks the self-contained nature of Helm charts.

**2. Pre-Upgrade Hooks with ConfigMaps:** Some charts store version metadata in ConfigMaps via pre-upgrade hooks, then reference these values in templates. This creates ordering dependencies, increases the number of Kubernetes resources, and can fail if hooks don't execute properly.

**3. Values File Conventions:** Requiring users to manually specify the previous version in values files is error-prone and defeats the purpose of Helm tracking release history.

### Real-World Impact

The lack of previous version metadata at template time prevents or significantly complicates several legitimate use cases:

**Breaking Changes:** When a chart introduces breaking changes (e.g., renaming a Secret, changing a ConfigMap structure, or modifying PVC specifications), there's no clean way to handle the migration. Chart authors must either force users through manual steps or abandon backwards compatibility entirely.

**Conditional Resource Creation:** Charts cannot conditionally create migration Jobs or temporary resources based on the version delta. For example, a database chart upgrading from v1.x to v2.x might need to run a one-time data migration Job only when crossing that major version boundary.

**Smart Defaults:** Charts cannot provide intelligent defaults based on what was previously deployed. A chart might want to preserve certain legacy behaviors for existing installations while adopting new defaults for fresh installations, but cannot distinguish between these scenarios at template time.

**Blue-Green Deployments:** Advanced deployment strategies that require knowledge of both the old and new versions cannot be implemented purely within Helm templates, forcing users to orchestrate these scenarios with external tools.

### Why Template-Time Access Matters

Post-rendering solutions fundamentally break Helm's design philosophy. Template rendering should be deterministic and self-contained—the same chart with the same values should produce the same output. Post-renderers violate this principle by introducing external dependencies and cluster state into the rendering process at the wrong layer.

Making previous chart metadata available during template rendering keeps upgrade logic where it belongs: in the chart itself. This maintains the portability, testability, and transparency that make Helm valuable while enabling sophisticated upgrade scenarios that are currently impossible or require significant infrastructure around Helm.

## Rationale

### Naming: `.DeployedChart`

The choice of `.DeployedChart` as the object name was made after considering several alternatives:

- **`.PreviousChart`**: Rejected due to ambiguity. "Previous" could mean the chart from the prior revision in history, or the chart being replaced. During rollback operations, "previous" becomes especially confusing.
- **`.InstalledChart`**: Rejected because "installed" could be confused with the chart currently being installed (the target of the operation).
- **`.CurrentChart`**: Rejected because "current" is ambiguous—it could refer to either the chart currently deployed or the chart currently being installed.
- **`.Release.Deployed.Chart`**: While semantically clear, this nested structure was rejected for simplicity and consistency with the existing top-level `.Chart` object.

`.DeployedChart` was chosen because:
- "Deployed" unambiguously means "what is currently running in the cluster"
- It maintains consistency with Helm terminology (deployed releases, deployment status)
- It works clearly for both upgrade and rollback scenarios
- It follows the established pattern of top-level template objects like `.Chart`, `.Release`, and `.Values`

### Making `.DeployedChart` nil for Fresh Installs

When no previous release exists (during `helm install`), `.DeployedChart` is set to `nil` rather than an empty struct or having default/zero values. This decision was made because:

- It follows idiomatic Go and template patterns for representing absence of data
- It enables simple, natural existence checks: `{{ if .DeployedChart }}`
- It prevents confusion between "no deployed chart" and "deployed chart with empty/zero values"
- It makes the template's intent explicit—the absence of a deployed chart is meaningful information

### Same Metadata Structure as `.Chart`

`.DeployedChart` exposes the same metadata fields as `.Chart` for consistency and simplicity. This includes fields like `Name`, `Version`, `AppVersion`, `Description`, `Keywords`, etc.

### Available During Upgrade and Rollback Operations

`.DeployedChart` is populated during both `helm upgrade` and `helm rollback` operations because both scenarios involve transitioning from one deployed state to another. In both cases:

- There is a currently deployed release that templates may need to reason about
- Version-aware logic is valuable (e.g., handling migrations, conditional resources)
- The semantics of "deployed chart" remain clear and unambiguous

`.DeployedChart` is explicitly **not** available during:
- `helm install`: No deployed chart exists; `.DeployedChart` would always be nil, providing no value
- `helm template`: See "Dry-Run and Template Operations" below
- `helm install --dry-run`: See "Dry-Run and Template Operations" below

### Chart Metadata Only (Not Full Release Data)

This proposal intentionally limits `.DeployedChart` to chart metadata and does not expose the full release object, which would include:
- Previous values (`.DeployedRelease.Values`)
- Previous manifest (`.DeployedRelease.Manifest`)
- Release metadata (revision number, timestamps, status, etc.)

**Rejected in this proposal but could be added later:**

**Previous Values**: While `.DeployedRelease.Values` would enable more sophisticated upgrade logic, it raises security concerns:
- Values files frequently contain sensitive data (passwords, API keys, certificates)
- Exposing previous values in templates could lead to accidental leakage in rendered manifests
- Users can already query previous values via `lookup()` to ConfigMaps/Secrets if needed
- If added in the future, strong warnings about secret handling would be required

**Previous Manifest**: The full previous manifest would be:
- Potentially very large (performance impact on template rendering)
- Complex to parse and reason about in templates
- Not necessary for most version-aware logic scenarios
- Better handled by Helm's existing three-way merge during upgrades

**Release Metadata**: While release revision numbers, timestamps, and status could be useful, they add complexity without clear compelling use cases. Chart metadata (especially version/appVersion) is sufficient for the primary use case of version-aware upgrade logic.

This proposal focuses on chart metadata as it solves 90% of use cases while maintaining security and simplicity. Future HIPs could extend `.DeployedChart` or introduce `.DeployedRelease` if compelling use cases emerge.

### Opt-Out Flag

To provide flexibility for users who don't want this feature (for example, for security reasons or to maintain strict template determinism), a new flag `--disable-deployed-chart` will be added to `helm upgrade` and `helm rollback`:

```bash
helm upgrade myrelease mychart --disable-deployed-chart
```

## Specification

The following outlines the syntax and semantics of the proposed changes.

### New Template Object: `.DeployedChart`

- **Type**: Object
- **Available in**: `helm upgrade`, `helm rollback`
- **Populated from**: Metadata of the currently deployed chart version in the cluster
- **Nil when**: No previous release exists (e.g., during fresh install)

### Metadata Fields

`.DeployedChart` exposes the same fields as `.Chart`:

- `Name`: The name of the chart.
- `Version`: The current version of the chart.
- `AppVersion`: The version of the app enclosed in the chart.
- `Description`: A brief description of the chart.
- `Keywords`: Keywords associated with the chart.
- `Home`: The home URL of the chart.
- `Sources`: List of source URLs for the chart.
- `Dependencies`: List of chart dependencies.
- `Maintainers`: List of maintainers of the chart.
- `Icon`: The icon URL of the chart.
- `APIVersion`: The API version of the chart.
- `Condition`: The condition for the chart.
- `Tags`: Tags associated with the chart.
- `Deprecated`: Deprecated status of the chart.
- `Annotations`: Annotations for the chart.
- `KubeVersion`: The Kubernetes version the chart is compatible with.
- `Type`: The type of the chart.

### Usage in Templates

Templates can access the deployed chart metadata using the `.DeployedChart` object. For example:

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: my-config
data:
	currentVersion: {{ .Chart.Version | quote }}
		previousVersion: {{ dig "Version" "none" .DeployedChart | quote }}
```

### Dry-Run and Template Operations

`.DeployedChart` is not available during `helm template` or `helm install --dry-run`. These operations do not have an associated deployed release, so the concept of a "deployed chart" does not apply. Templates should not rely on `.DeployedChart` being present in these contexts.

### Opt-Out Usage

Users who wish to disable this feature can use the `--disable-deployed-chart` flag:

```bash
helm upgrade myrelease mychart --disable-deployed-chart
```

When this flag is set:

- The `.DeployedChart` object will not be populated
- Templates should not use `.DeployedChart` to avoid errors
- This allows users to maintain existing workflows or security postures

## Backwards compatibility

This proposal is designed to be backwards compatible with existing charts and templates. The new `.DeployedChart` object is additive and does not remove or alter any existing functionality.

Charts that do not use the `.DeployedChart` object will continue to function as before. There are no breaking changes introduced by this proposal.

## Security implications

Care must be taken to ensure that sensitive data is not inadvertently exposed through the new `.DeployedChart` object. In particular, chart authors should be aware that:

- Chart metadata (from Chart.yaml) does not typically contain secrets, as it's a best practice to keep sensitive data out of chart metadata files
- The `lookup()` function can be used to query previous values if needed, with appropriate security considerations

Documentation and warnings should be provided to guide chart authors in using this feature securely.

## How to teach this

Documentation should be updated to include:

- An explanation of the new `.DeployedChart` object and its purpose
- Examples of how to use `.DeployedChart` in templates, including how it replaces common workarounds:
	- **Breaking Change Migrations**: Templates can conditionally create both old and new resources (like Secrets or ConfigMaps) during upgrades by checking the deployed chart version, eliminating the need for pre-upgrade hooks that store version metadata in ConfigMaps or complex manual coordination steps
	- **Conditional Migration Jobs**: One-time data migration Jobs can be created only when crossing specific version boundaries by comparing deployed and target versions, removing the requirement for post-renderers that query the cluster and inject migration resources
	- **Version-Aware Defaults**: Charts can preserve legacy behavior for existing installations while adopting new defaults for fresh installs by checking if a deployed chart exists and comparing versions, replacing manual values file conventions where users must specify previous versions
	- **Blue-Green Deployment Orchestration**: Advanced deployment strategies can be implemented based on version deltas (like major vs. minor upgrades) without requiring external orchestration tools or post-renderers
- Guidance on security implications and best practices
- Information about the opt-out flag and its usage

## Reference implementation

This section will link to the reference implementation once available.

## Rejected ideas

The following ideas were considered but not pursued:

- Exposing the full release object (`.DeployedRelease`) instead of just chart metadata
- Making `.DeployedChart` available during `helm install` or `helm template`
- Using a different naming convention for the object

## Open issues

- None at this time.
