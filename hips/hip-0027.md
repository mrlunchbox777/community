---
hip: 0027
title: "Expose Previously Installed Chart Metadata During Template Rendering"
authors: [ "Andrew Shoell <mrlunchbox777@gmail.com>" ]
created: "2025-11-12"
type: "feature"
status: "draft"
---

## Abstract

This HIP proposes exposing metadata from the currently deployed chart version during template rendering for upgrade and rollback operations. Currently, Helm templates have access to `.Chart` which provides metadata about the chart being installed (name, version, appVersion, etc.), but no equivalent access to information about the release currently deployed in the cluster. This limitation prevents chart authors from implementing upgrade-aware logic, forcing them to rely on complex workarounds such as post-renderers, pre-upgrade hooks, or manual values file conventions.

The proposal introduces a new `.DeployedChart` object available in the template context during all Helm operations. This object contains the same metadata structure as `.Chart` but is populated with values from the chart version currently running in the cluster during upgrade and rollback operations. When no deployed release exists (such as during initial installation, dry-run operations, or when explicitly disabled), `.DeployedChart` is nil, allowing templates to safely check for its existence with `{{ if .DeployedChart }}`.

This enhancement enables chart maintainers to build intelligent upgrade paths that can detect version transitions, implement breaking change migrations, conditionally apply resources based on version deltas, and provide seamless user experiences during chart lifecycle operations—all within the chart itself without requiring external tooling. An optional `--disable-deployed-chart` flag allows users to opt out of this feature for security or determinism requirements.

## Motivation

### Current Limitations

Helm's current template rendering model provides comprehensive information about the chart being installed through the `.Chart` object, but offers no native way to access metadata from the currently deployed release during template evaluation. This asymmetry creates significant challenges for chart authors who need to implement version-aware upgrade logic.

Today, chart developers who need to handle version-specific migrations or conditional upgrades must resort to workarounds that are complex, fragile, and outside Helm's intended design:

**1. Post-Renderers:** The most common workaround involves implementing custom post-renderers that modify manifests after template rendering but before application. These external tools must:
- Query the cluster to retrieve the current release
- Parse and understand the rendered manifests
- Make version-aware modifications to YAML
- Handle edge cases like initial installations vs. upgrades

This approach is problematic because it moves upgrade logic outside the chart itself, requires users to install additional tooling, and breaks the self-contained nature of Helm charts.

**2. Pre-Upgrade Hooks with ConfigMaps:** Some charts store version metadata in ConfigMaps via pre-upgrade hooks, then reference these values in templates. This creates ordering dependencies, increases the number of Kubernetes resources, and can fail if hooks don't execute properly.

**3. Values File Conventions:** Requiring users to manually specify the previous version in values files is error-prone and defeats the purpose of Helm tracking release history.

### Real-World Impact

The lack of deployed chart metadata at template time prevents or significantly complicates several legitimate use cases:

**Breaking Changes:** When a chart introduces breaking changes (e.g., renaming a Secret, changing a ConfigMap structure, or modifying PVC specifications), there's no clean way to handle the migration. Chart authors must either force users through manual steps or abandon backwards compatibility entirely.

**Conditional Resource Creation:** Charts cannot conditionally create migration Jobs or temporary resources based on the version delta. For example, a database chart upgrading from v1.x to v2.x might need to run a one-time data migration Job only when crossing that major version boundary.

**Smart Defaults:** Charts cannot provide intelligent defaults based on what was previously deployed. A chart might want to preserve certain legacy behaviors for existing installations while adopting new defaults for fresh installations, but cannot distinguish between these scenarios at template time.

**Blue-Green Deployments:** Advanced deployment strategies that require knowledge of both the old and new versions cannot be implemented purely within Helm templates, forcing users to orchestrate these scenarios with external tools.

### Why Template-Time Access Matters

Post-rendering solutions fundamentally break Helm's design philosophy. Template rendering should be deterministic and self-contained—the same chart with the same values should produce the same output. Post-renderers violate this principle by introducing external dependencies and cluster state into the rendering process at the wrong layer.

Making deployed chart metadata available during template rendering keeps upgrade logic where it belongs: in the chart itself. This maintains the portability, testability, and transparency that make Helm valuable while enabling sophisticated upgrade scenarios that are currently impossible or require significant infrastructure around Helm.

## Rationale

This section describes the design decisions made for this proposal and the reasoning behind them.

### Naming: `.DeployedChart`

The choice of `.DeployedChart` as the object name was made after considering several alternatives:

- **`.PreviousChart`**: Rejected due to ambiguity. "Previous" could mean the chart from the prior revision in history, or the chart being replaced. During rollback operations, "previous" becomes especially confusing.
- **`.InstalledChart`**: Rejected because "installed" could be confused with the chart currently being installed (the target of the operation).
- **`.CurrentChart`**: Rejected because "current" is ambiguous—it could refer to either the chart currently deployed or the chart currently being installed.
- **`.Release.Deployed.Chart`**: While semantically clear, this nested structure was rejected for simplicity and consistency with the existing top-level `.Chart` object.

`.DeployedChart` was chosen because:
- "Deployed" unambiguously means "what is currently running in the cluster"
- It maintains consistency with Helm terminology (deployed releases, deployment status)
- It works clearly for both upgrade and rollback scenarios
- It follows the established pattern of top-level template objects like `.Chart`, `.Release`, and `.Values`

### Always Available as Template Object

`.DeployedChart` is always present in the template context, even when it contains no data (nil). This design decision ensures:

- **Consistent template behavior**: Templates don't need conditional logic to check if the object exists vs. if it has data
- **Follows Go template conventions**: nil is the idiomatic way to represent absence of data
- **Simplifies template code**: `{{ if .DeployedChart }}` works in all scenarios
- **Enables testing**: Templates using `.DeployedChart` can be tested with `helm template` without undefined variable errors
- **Prevents template failures**: References to `.DeployedChart` don't cause rendering errors

### Making `.DeployedChart` nil When No Deployed Release Exists

When no deployed release exists, `.DeployedChart` is set to `nil` rather than an empty struct or having default/zero values. This decision was made because:

- It follows idiomatic Go and template patterns for representing absence of data
- It enables simple, natural existence checks: `{{ if .DeployedChart }}`
- It prevents confusion between "no deployed chart" and "deployed chart with empty/zero values"
- It makes the template's intent explicit—the absence of a deployed chart is meaningful information

### Same Metadata Structure as `.Chart`

`.DeployedChart` exposes the same metadata fields as `.Chart` for consistency and simplicity. This includes fields like `Name`, `Version`, `AppVersion`, `Description`, `Keywords`, `Home`, `Sources`, `Dependencies`, `Maintainers`, `Icon`, `APIVersion`, `Condition`, `Tags`, `Deprecated`, `Annotations`, `KubeVersion`, and `Type`.

This decision provides:
- **Consistency**: Chart authors already understand the `.Chart` structure
- **Simplicity**: No need to learn a new metadata schema
- **Sufficiency**: These fields cover the vast majority of version-aware logic use cases
- **Future-proofing**: If new metadata fields are added to charts, they automatically become available in `.DeployedChart`

### Available During Upgrade and Rollback Operations

`.DeployedChart` is populated with chart metadata only during `helm upgrade` and `helm rollback` operations when a deployed release exists in the cluster. In all other scenarios, `.DeployedChart` is nil.

**Populated with chart metadata:**
- `helm upgrade` (when upgrading an existing release)
- `helm rollback` (when rolling back to a previous revision)

**Always nil:**
- `helm install` - No deployed release exists yet
- `helm upgrade` (first install) - Treated as install, no prior release
- `helm template` - No cluster context available
- `helm install --dry-run` - No cluster context available
- `helm upgrade --dry-run` - No cluster access during dry-run
- When `--disable-deployed-chart` flag is used - Explicitly disabled

### Chart Metadata Only (Not Full Release Data)

This proposal intentionally limits `.DeployedChart` to chart metadata and does not expose the full release object, which would include previous values, previous manifest, or detailed release metadata (revision number, timestamps, status, etc.).

**Rejected in this proposal but could be added later:**

**Previous Values**: While `.DeployedRelease.Values` would enable more sophisticated upgrade logic, it raises security concerns:
- Values files frequently contain sensitive data (passwords, API keys, certificates)
- Exposing previous values in templates could lead to accidental leakage in rendered manifests
- Users can already query previous values via `lookup()` to ConfigMaps/Secrets if needed
- If added in the future, strong warnings about secret handling would be required

**Previous Manifest**: The full deployed manifest would be:
- Potentially very large (performance impact on template rendering)
- Complex to parse and reason about in templates
- Not necessary for most version-aware logic scenarios
- Better handled by Helm's existing three-way merge during upgrades

**Release Metadata**: While release revision numbers, timestamps, and status could be useful, they add complexity without clear compelling use cases. Chart metadata (especially version/appVersion) is sufficient for the primary use case of version-aware upgrade logic.

This proposal focuses on chart metadata as it solves 90% of use cases while maintaining security and simplicity. Future HIPs could extend `.DeployedChart` or introduce `.DeployedRelease` if compelling use cases emerge.

### Opt-Out Flag

To provide flexibility for users who don't want this feature (for example, for security reasons or to maintain strict template determinism), a new flag `--disable-deployed-chart` will be added to `helm upgrade` and `helm rollback`:

```bash
helm upgrade myrelease mychart --disable-deployed-chart
```

When this flag is set, `.DeployedChart` will be nil even if a deployed release exists. This allows:
- Organizations with strict security policies to disable the feature
- Testing scenarios where deterministic output is required
- Gradual adoption without forcing all users to change behavior

The flag approach is preferred over environment variables or configuration files because:
- It's explicit and visible in the command
- It follows Helm's existing pattern of operation-specific flags
- It can be easily scripted and automated

### Handling Different Chart Names

If a user changes the chart being used for a release (e.g., switching from `stable/postgresql` to `bitnami/postgresql`), `.DeployedChart` will still be populated with the metadata from the currently deployed release, even though `.Chart.Name` and `.DeployedChart.Name` will differ.

This decision was made because:
- Chart authors may intentionally want to detect chart name changes
- Filtering by name would hide potentially important information
- Templates can easily check `{{ if eq .Chart.Name .DeployedChart.Name }}` if they want to verify the chart name hasn't changed
- It's more transparent—let chart authors decide how to handle mismatches

### Deployed Chart Reflects Helm's Record

`.DeployedChart` reflects the chart metadata from Helm's stored release record, not the actual state of resources in the cluster. If a user manually modified resources using `kubectl edit` or other tools, those changes are not reflected in `.DeployedChart`.

This is consistent with Helm's existing behavior:
- Helm tracks what Helm deployed, not arbitrary cluster state
- The three-way merge during upgrades already uses Helm's release record as the baseline
- Attempting to reflect actual cluster state would be complex, slow, and error-prone

Chart authors who need to inspect actual cluster state should use the `lookup()` function, which is designed for that purpose.

### Dry-Run and Template Operations

`.DeployedChart` is always nil during `helm template` and dry-run operations (`helm install --dry-run`, `helm upgrade --dry-run`) because these commands are intentionally cluster-agnostic and should remain deterministic without cluster context.

The object is present (but nil) to ensure templates that reference `.DeployedChart` don't fail with undefined variable errors during templating and dry-run operations.

However, we recognize that chart authors may want to test templates that use `.DeployedChart`. To support this use case:

**Testing Recommendation**: Chart authors should structure their templates to handle nil `.DeployedChart` gracefully:

```yaml
{{- if .DeployedChart }}
  {{- if semverCompare ">=2.0.0" .Chart.Version }}
    {{- if semverCompare "<2.0.0" .DeployedChart.Version }}
      # Migration logic for 1.x -> 2.x
    {{- end }}
  {{- end }}
{{- end }}
```

**Future Extension**: A future enhancement could allow plugins or test frameworks to provide mock `.DeployedChart` data during `helm template` operations, similar to how values can be provided via `--values` or `--set`. This would enable:
- Testing upgrade logic without a cluster
- Documentation and examples that demonstrate `.DeployedChart` usage
- CI/CD pipelines that validate upgrade paths

This could be implemented as:
- A `--mock-deployed-chart` flag that accepts a chart metadata file
- A Helm SDK feature for test frameworks
- A plugin interface for injecting template context

However, this functionality is intentionally left out of this initial proposal to keep the scope focused. The core feature (making `.DeployedChart` available during real upgrades/rollbacks) can be implemented and proven valuable before adding testing conveniences.

## Specification

The following outlines the syntax and semantics of the proposed changes.

### New Template Object: `.DeployedChart`

A new top-level template object `.DeployedChart` will be available in all template contexts. The object is populated with chart metadata during `helm upgrade` and `helm rollback` operations when a deployed release exists. In all other scenarios, the object is nil.

**Always available:** The `.DeployedChart` object is present in the template context for all Helm operations to ensure consistent template behavior and prevent undefined variable errors.

**Populated with data:**
- `helm upgrade` (when upgrading an existing release)
- `helm rollback` (when rolling back to a previous revision)

**Always nil:**
- `helm install` - No deployed release exists
- `helm upgrade` (first install) - No deployed release exists
- `helm template` - No cluster context
- `helm install --dry-run` - No cluster context
- `helm upgrade --dry-run` - No cluster context during dry-run
- When `--disable-deployed-chart` flag is used

**Populated from:** When not nil, the metadata of the chart version currently deployed in the cluster, retrieved from Helm's release record.

### Metadata Fields

`.DeployedChart` exposes the same structure and fields as `.Chart`:

| Field | Type | Description |
|-------|------|-------------|
| `Name` | string | The name of the chart |
| `Version` | string | The SemVer 2 version of the chart |
| `AppVersion` | string | The version of the app enclosed in the chart |
| `Description` | string | A brief description of the chart |
| `Keywords` | []string | Keywords associated with the chart |
| `Home` | string | The home URL of the chart |
| `Sources` | []string | List of source URLs for the chart |
| `Dependencies` | []Dependency | List of chart dependencies |
| `Maintainers` | []Maintainer | List of maintainers |
| `Icon` | string | The icon URL of the chart |
| `APIVersion` | string | The API version of the chart (e.g., "v2") |
| `Condition` | string | The condition for the chart |
| `Tags` | string | Tags associated with the chart |
| `Deprecated` | bool | Whether the chart is deprecated |
| `Annotations` | map[string]string | Annotations for the chart |
| `KubeVersion` | string | The Kubernetes version constraint |
| `Type` | string | The type of the chart (application or library) |

### Usage in Templates

Templates can access the deployed chart metadata using the `.DeployedChart` object. Templates should always check for nil before accessing fields:

**Basic existence check:**
```yaml
{{- if .DeployedChart }}
# A previous release exists
currentVersion: {{ .Chart.Version }}
previousVersion: {{ .DeployedChart.Version }}
{{- else }}
# Fresh installation
currentVersion: {{ .Chart.Version }}
previousVersion: "none"
{{- end }}
```

**Version comparison for migrations:**
```yaml
{{- if .DeployedChart }}
{{- if and (semverCompare ">=2.0.0" .Chart.Version) (semverCompare "<2.0.0" .DeployedChart.Version) }}
---
# Only created when upgrading from 1.x to 2.x
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ include "mychart.fullname" . }}-migration
spec:
  template:
    spec:
      containers:
      - name: migrate
        image: myapp/migrator:{{ .Chart.AppVersion }}
        command: ["migrate", "v1-to-v2"]
{{- end }}
{{- end }}
```

**Handling breaking changes:**
```yaml
apiVersion: v1
kind: Secret
metadata:
  {{- if and .DeployedChart (semverCompare "<2.0.0" .DeployedChart.Version) }}
  # Keep old name for backwards compatibility during upgrade
  name: {{ include "mychart.fullname" . }}-legacy-secret
  {{- else }}
  # Use new name for fresh installs or post-2.0 upgrades
  name: {{ include "mychart.fullname" . }}-credentials
  {{- end }}
type: Opaque
data:
  password: {{ .Values.password | b64enc }}
```

**Detecting chart name changes:**
```yaml
{{- if .DeployedChart }}
{{- if ne .Chart.Name .DeployedChart.Name }}
# WARNING: Chart name has changed from {{ .DeployedChart.Name }} to {{ .Chart.Name }}
# This may indicate a migration between different chart repositories
{{- end }}
{{- end }}
```

### Command-Line Flag

A new flag `--disable-deployed-chart` is added to `helm upgrade` and `helm rollback`:

```bash
# Normal upgrade with .DeployedChart available
helm upgrade myrelease mychart

# Upgrade with .DeployedChart disabled (will be nil)
helm upgrade myrelease mychart --disable-deployed-chart
```

When this flag is set, `.DeployedChart` will be nil regardless of whether a deployed release exists.

### Behavior During Different Operations

| Operation | `.DeployedChart` Availability | `.DeployedChart` Value |
|-----------|-------------------------------|------------------------|
| `helm install` | Always available | Always `nil` (no deployed release) |
| `helm upgrade` (first install) | Always available | `nil` (no deployed release) |
| `helm upgrade` (actual upgrade) | Always available | Populated with deployed chart metadata |
| `helm upgrade --disable-deployed-chart` | Always available | `nil` (explicitly disabled) |
| `helm upgrade --dry-run` | Always available | Always `nil` (no cluster context) |
| `helm rollback` | Always available | Populated with currently deployed chart metadata |
| `helm template` | Always available | Always `nil` (no cluster context) |
| `helm install --dry-run` | Always available | Always `nil` (no cluster context) |

**Note:** The object is always present in the template context to prevent template errors when referencing `.DeployedChart`, even when it contains no data.

## Backwards Compatibility

This proposal is designed to be fully backwards compatible with existing charts and templates. The new `.DeployedChart` object is purely additive and does not remove or alter any existing functionality.

**For existing charts:**
- Charts that do not reference `.DeployedChart` will continue to function exactly as before
- No changes to existing templates are required
- No behavioral changes occur unless `.DeployedChart` is explicitly used

**Safe nil handling:**
- Go templates safely handle nil objects—accessing fields on nil returns zero values without errors
- The recommended pattern `{{ if .DeployedChart }}` provides explicit nil checking
- Templates written with proper nil checks will work correctly in all scenarios (fresh installs, upgrades, dry-runs)

**No breaking changes:**
- Existing template objects (`.Chart`, `.Release`, `.Values`, etc.) remain unchanged
- Existing template functions continue to work identically
- Helm CLI commands retain their current behavior
- Release records and storage format are unaffected

## Security Implications

This proposal has been designed with security considerations in mind:

**What is NOT exposed:**
- Previous values are NOT exposed (values may contain secrets, passwords, API keys)
- Previous manifest is NOT exposed (could contain sensitive rendered data)
- Only chart metadata from Chart.yaml is exposed, which should not contain sensitive information

**Best practices:**
- Chart authors should not store sensitive data in Chart.yaml metadata
- The `--disable-deployed-chart` flag allows organizations to opt out if needed
- Chart metadata is already available in release records, so this doesn't expose new data—it only makes existing data accessible at template time

**Potential concerns:**
- If chart authors have improperly stored sensitive data in Chart.yaml annotations or descriptions, that data could now be used in templates. However, this would already be a security anti-pattern.
- Templates that use `.DeployedChart` should be reviewed to ensure they don't inadvertently leak information into rendered manifests that would be stored in release records.

**Recommendations:**
- Documentation should emphasize that Chart.yaml should never contain secrets
- Chart authors should use values and Kubernetes Secrets for sensitive data
- Templates using `.DeployedChart` should be tested to ensure they handle all scenarios appropriately

## How to Teach This

### Documentation Updates

The following documentation should be added or updated:

**1. Template Objects Reference:**
Add `.DeployedChart` to the list of built-in objects available in templates, with clear documentation about when it's populated and when it's nil.

**2. Upgrade Guide:**
Create a guide titled "Implementing Version-Aware Upgrades" that covers:
- How to check if `.DeployedChart` exists
- Common patterns for version comparisons
- Examples of handling breaking changes
- Best practices for backwards compatibility

**3. Migration Guide for Existing Workarounds:**
Show chart authors how to replace existing workarounds:

**Replacing Post-Renderers:**
```yaml
# Before: Required external post-renderer to inject migration job
# After: Conditional resource creation in templates
{{- if .DeployedChart }}
{{- if and (semverCompare ">=2.0.0" .Chart.Version) (semverCompare "<2.0.0" .DeployedChart.Version) }}
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ include "mychart.fullname" . }}-migration
spec:
  template:
    spec:
      containers:
      - name: migrate
        image: myapp/migrator:{{ .Chart.AppVersion }}
        command: ["migrate", "v1-to-v2"]
{{- end }}
{{- end }}
```

**Replacing Pre-Upgrade Hooks with ConfigMaps:**
```yaml
# Before: Used pre-upgrade hook to store version in ConfigMap
# After: Direct access to deployed version
apiVersion: v1
kind: ConfigMap
metadata:
  name: migration-config
data:
  previousVersion: {{ .DeployedChart.Version | default "none" | quote }}
  requiresMigration: {{ if and .DeployedChart (semverCompare "<2.0.0" .DeployedChart.Version) }}"true"{{ else }}"false"{{ end }}
```

**Replacing Manual Values File Conventions:**
```yaml
# Before: Required users to set values.previousVersion manually
# After: Automatic detection
{{- if .DeployedChart }}
{{- if ne .Values.behavior .DeployedChart.Annotations.defaultBehavior }}
# User has changed behavior from previous default
{{- end }}
{{- end }}
```

**4. Common Use Case Examples:**

**Example 1: Breaking Change Migration (Renamed Secret)**
```yaml
{{- if and .DeployedChart (semverCompare "<3.0.0" .DeployedChart.Version) }}
# Keep old secret for backwards compatibility during upgrade
apiVersion: v1
kind: Secret
metadata:
  name: {{ include "mychart.fullname" . }}-old-credentials
  annotations:
    "helm.sh/resource-policy": keep
type: Opaque
data:
  password: {{ .Values.password | b64enc }}
---
{{- end }}
# New secret with updated name
apiVersion: v1
kind: Secret
metadata:
  name: {{ include "mychart.fullname" . }}-credentials
type: Opaque
data:
  password: {{ .Values.password | b64enc }}
```

**Example 2: Conditional Data Migration Job**
```yaml
{{- if .DeployedChart }}
{{- $major := semver .Chart.Version | int }}
{{- $deployedMajor := semver .DeployedChart.Version | int }}
{{- if gt $major $deployedMajor }}
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ include "mychart.fullname" . }}-migrate-v{{ $deployedMajor }}-to-v{{ $major }}
  annotations:
    "helm.sh/hook": pre-upgrade
    "helm.sh/hook-weight": "-5"
    "helm.sh/hook-delete-policy": before-hook-creation
spec:
  template:
    spec:
      restartPolicy: OnFailure
      containers:
      - name: migrate
        image: "{{ .Values.image.repository }}:{{ .Chart.AppVersion }}"
        command: ["migrate", "v{{ $deployedMajor }}-to-v{{ $major }}"]
{{- end }}
{{- end }}
```

**Example 3: Smart Defaults Based on Installation vs Upgrade**
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "mychart.fullname" . }}-config
data:
  {{- if .DeployedChart }}
  # Preserve legacy behavior for existing installations
  useNewFeature: {{ .Values.useNewFeature | default "false" | quote }}
  {{- else }}
  # Enable new feature by default for fresh installations
  useNewFeature: {{ .Values.useNewFeature | default "true" | quote }}
  {{- end }}
```

**5. Troubleshooting Section:**
- What to do if `.DeployedChart` is unexpectedly nil
- How to test templates that use `.DeployedChart`
- Common pitfalls and how to avoid them

**6. Chart Linting:**
Consider updating `helm lint` to provide helpful warnings for common issues:
- Warn if templates use `.DeployedChart` without nil checks (e.g., direct field access without `{{ if .DeployedChart }}`)
- Suggest best practices for version comparison logic
- Flag potential issues with upgrade-specific resources that might not be cleaned up

This would help chart authors catch potential issues early in development and promote correct usage patterns.

## Reference Implementation

A reference implementation will be provided in a future pull request to the Helm repository. The implementation will:

1. Extend the template rendering context to include `.DeployedChart`
2. Populate `.DeployedChart` from the release record during upgrade and rollback
3. Add the `--disable-deployed-chart` flag to relevant commands
4. Include unit tests for all scenarios (nil handling, version comparisons, etc.)
5. Include integration tests for upgrade and rollback workflows

## Rejected Ideas

The following ideas were considered during the design of this HIP but were ultimately rejected:

### Exposing Full Release Object

**Idea:** Expose `.DeployedRelease` with values, manifest, and complete metadata instead of just `.DeployedChart`.

**Rejection Reason:** 
- Security concerns with exposing previous values (may contain secrets)
- Performance concerns with exposing previous manifest (could be very large)
- Complexity concerns (chart metadata is sufficient for most use cases)
- Can be added later if compelling use cases emerge

### Different Naming Conventions

**Ideas considered:**
- `.PreviousChart` - Ambiguous for rollbacks ("previous" could mean different things)
- `.InstalledChart` - Confusing with the chart currently being installed
- `.CurrentChart` - Ambiguous (which chart is "current"?)
- `.Release.Deployed.Chart` - Unnecessarily nested, breaks consistency with `.Chart`
- `.OldChart` - Informal and ambiguous

**Rejection Reason:** `.DeployedChart` is the clearest and most consistent with Helm terminology. "Deployed" unambiguously means "what's currently running in the cluster."

### Exposing Only Version Strings

**Idea:** Only expose `.DeployedVersion` and `.DeployedAppVersion` as simple strings instead of the full chart object.

**Rejection Reason:**
- Inconsistent with `.Chart` object structure
- Prevents access to other useful metadata (type, deprecated status, annotations)
- Would need to be expanded later anyway if more fields are needed
- Simpler to reuse existing Chart metadata structure

### Environment Variable or Config File for Opt-Out

**Idea:** Control the feature via environment variable (`HELM_DISABLE_DEPLOYED_CHART`) or Helm configuration file instead of CLI flag.

**Rejection Reason:**
- Less explicit than a CLI flag
- Harder to see in scripts and documentation
- Doesn't follow Helm's pattern of operation-specific flags
- Could cause confusion if set globally but not desired for specific operations
- Environment variables can be accidentally inherited in unexpected contexts

### Querying Cluster During `helm template`

**Idea:** Allow `.DeployedChart` to be populated during `helm template` by querying the cluster if kubectl context is available.

**Rejection Reason:**
- Violates the design principle that `helm template` should be cluster-agnostic
- Would make template rendering non-deterministic
- Could cause security issues if templating in one environment with data from another
- Would require cluster credentials during templating operations
- A future mock/plugin system is a better solution for testing

### Making `.DeployedChart` Mutable

**Idea:** Allow templates to modify `.DeployedChart` values.

**Rejection Reason:**
- Template objects should be read-only to maintain determinism
- Would create confusion about source of truth (is it from the cluster or from template modifications?)
- Could lead to complex bugs and security issues
- Violates Helm's template rendering model where templates are purely declarative
- No clear use case that couldn't be better solved with template variables

## Open Issues

None at this time. This HIP is ready for community review and feedback.

## References

- [Helm Built-in Objects Documentation](https://helm.sh/docs/chart_template_guide/builtin_objects/)
- [Helm Template Functions and Pipelines](https://helm.sh/docs/chart_template_guide/functions_and_pipelines/)
- [Go Template Documentation](https://pkg.go.dev/text/template)
- [Semantic Versioning 2.0.0](https://semver.org/)
